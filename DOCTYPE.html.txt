<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 手机端核心适配：禁止缩放、适配视口 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>手机端3D粒子交互系统</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000; 
            font-family: Arial, sans-serif; 
            touch-action: none; /* 禁用默认触屏行为，避免冲突 */
        }
        canvas { display: block; }
        /* 手机端大按钮：方便触摸 */
        .start-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 18px 36px;
            font-size: 18px;
            background: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 12px;
            z-index: 200;
            width: 80%;
            max-width: 300px;
        }
        /* 手机端提示文字：放大、高对比度 */
        .tips {
            position: fixed;
            top: 20px;
            left: 0;
            width: 100%;
            color: #fff;
            font-size: 14px;
            text-align: center;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 0;
        }
        /* 摄像头预览：适配手机竖屏 */
        #video {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 160px;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            z-index: 100;
            display: none;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <button class="start-btn" id="startBtn">点击开启摄像头<br>手势控制粒子</button>
    <div class="tips" id="tips">操作说明：<br>1. 张开手掌→粒子放大  握拳→缩小<br>2. 手掌左移→汇聚  右移→扩散<br>3. 触屏拖拽→旋转视角</div>
    <video id="video" autoplay playsinline muted></video>

    <!-- 引入轻量版依赖（适配手机加载速度） -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/tensorflow/3.19.0/tf.min.js"></script>

    <script>
        // ========== 1. 手机端适配初始化 ==========
        const startBtn = document.getElementById('startBtn');
        const tips = document.getElementById('tips');
        const videoElement = document.getElementById('video');
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        // ========== 2. Three.js 核心配置（手机性能优化） ==========
        // 场景/相机/渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "low-power" // 低功耗模式，适配手机
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);

        // 粒子配置（手机端减少数量，降低渲染压力）
        const particleCount = isMobile ? 1500 : 3000; // 手机1500个，电脑3000个
        let particleSize = isMobile ? 0.4 : 0.3; // 手机粒子稍大，更易看清
        const particles = [];
        const maxScale = isMobile ? 1.0 : 0.8;
        const minScale = isMobile ? 0.2 : 0.1;
        let spreadFactor = isMobile ? 18 : 20;
        const maxSpread = isMobile ? 35 : 40;
        const minSpread = isMobile ? 8 : 10;

        // 粒子几何体初始化
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);

        function initParticles() {
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // 球形分布，适配手机可视范围
                const radius = spreadFactor * 0.7;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);

                // 明亮颜色，手机屏幕更醒目
                colors[i3] = Math.random() * 0.9 + 0.1;
                colors[i3 + 1] = Math.random() * 0.9 + 0.1;
                colors[i3 + 2] = Math.random() * 0.9 + 0.1;

                // 低速运动，减少手机计算量
                velocities[i3] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;

                particles.push({
                    position: new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]),
                    velocity: new THREE.Vector3(velocities[i3], velocities[i3 + 1], velocities[i3 + 2]),
                    color: new THREE.Color(colors[i3], colors[i3 + 1], colors[i3 + 2])
                });
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }
        initParticles();

        // 粒子材质（手机端优化透明度和混合）
        const material = new THREE.PointsMaterial({
            size: particleSize,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            depthWrite: false // 解决手机端粒子遮挡问题
        });

        // 粒子系统添加到场景
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        camera.position.z = isMobile ? 55 : 60; // 手机相机稍近，适配屏幕

        // ========== 3. 触屏交互（替代鼠标，适配手机） ==========
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08; // 手机阻尼稍大，滑动更稳
        controls.minDistance = isMobile ? 25 : 30;
        controls.maxDistance = isMobile ? 120 : 150;
        controls.enablePan = false; // 禁用平移，减少手机误触
        controls.touches = {
            ONE: THREE.TOUCH.ROTATE, // 单指旋转
            TWO: THREE.TOUCH.NONE    // 双指禁用，避免冲突
        };

        // ========== 4. 手机端手势识别配置（MediaPipe 优化） ==========
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 0=轻量模型，适配手机性能
            minDetectionConfidence: 0.4,
            minTrackingConfidence: 0.4,
            selfieMode: true // 手机默认前置摄像头镜像，优化识别
        });

        // 手势识别回调（适配手机摄像头视角）
        hands.onResults((results) => {
            if (!results.multiHandLandmarks) return;
            const handLandmarks = results.multiHandLandmarks[0];

            // 计算手指张开程度（控制缩放）
            const thumbTip = handLandmarks[4];
            const indexTip = handLandmarks[8];
            const middleTip = handLandmarks[12];
            const ringTip = handLandmarks[16];
            const pinkyTip = handLandmarks[20];
            const wrist = handLandmarks[0];

            const distances = [
                getDistance(thumbTip, wrist),
                getDistance(indexTip, wrist),
                getDistance(middleTip, wrist),
                getDistance(ringTip, wrist),
                getDistance(pinkyTip, wrist)
            ];
            const avgDistance = distances.reduce((a, b) => a + b, 0) / 5;

            // 手机端扩大映射范围，手势更灵敏
            particleSize = THREE.MathUtils.mapLinear(avgDistance, 0.06, 0.22, minScale, maxScale);
            material.size = particleSize;

            // 手掌X坐标控制扩散（适配手机摄像头镜像）
            const handX = 1 - handLandmarks[9].x; // 镜像修正，左/右操作更直观
            spreadFactor = THREE.MathUtils.mapLinear(handX, 0.1, 0.9, minSpread, maxSpread);

            updateParticleSpread();
        });

        // ========== 5. 摄像头授权（手机端必须用户点击触发） ==========
        startBtn.addEventListener('click', async () => {
            try {
                startBtn.style.display = 'none';
                // 手机端摄像头权限请求（强制用户交互触发）
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 480 }, // 手机端降低分辨率，减少卡顿
                        height: { ideal: 640 },
                        facingMode: 'user' // 前置摄像头，更符合手机使用习惯
                    }
                });
                videoElement.srcObject = stream;
                videoElement.style.display = 'block';

                // 延迟启动识别，等待视频流稳定
                setTimeout(() => {
                    hands.send({ image: videoElement });
                }, 1000);

            } catch (error) {
                startBtn.style.display = 'block';
                alert('请允许摄像头权限！\n手机需在浏览器设置中开启');
                console.error('摄像头授权失败：', error);
            }
        });

        // ========== 6. 辅助函数（适配手机） ==========
        function getDistance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function updateParticleSpread() {
            for (let i = 0; i < particleCount; i++) {
                const p = particles[i];
                const targetRadius = spreadFactor;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const targetPosition = new THREE.Vector3(
                    targetRadius * Math.sin(phi) * Math.cos(theta),
                    targetRadius * Math.sin(phi) * Math.sin(theta),
                    targetRadius * Math.cos(phi)
                );
                p.position.lerp(targetPosition, isMobile ? 0.12 : 0.1); // 手机过渡稍快，响应更及时
            }
        }

        // ========== 7. 粒子更新（手机性能优化） ==========
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const p = particles[i];

                p.velocity.multiplyScalar(0.96);
                const maxBound = spreadFactor + 6;
                if (Math.abs(p.position.x) > maxBound) p.velocity.x *= -0.7;
                if (Math.abs(p.position.y) > maxBound) p.velocity.y *= -0.7;
                if (Math.abs(p.position.z) > maxBound) p.velocity.z *= -0.7;

                p.position.add(p.velocity);
                positions[i3] = p.position.x;
                positions[i3 + 1] = p.position.y;
                positions[i3 + 2] = p.position.z;

                // 颜色渐变（手机屏幕更鲜艳）
                p.color.r = Math.sin(p.position.x * 0.07) * 0.5 + 0.5;
                p.color.g = Math.sin(p.position.y * 0.07) * 0.5 + 0.5;
                p.color.b = Math.sin(p.position.z * 0.07) * 0.5 + 0.5;
                colors[i3] = p.color.r;
                colors[i3 + 1] = p.color.g;
                colors[i3 + 2] = p.color.b;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }

        // ========== 8. 动画循环（手机帧率优化） ==========
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateParticles();
            renderer.render(scene, camera);
            
            // 手机端降低识别频率，减少卡顿
            if (videoElement.srcObject && (Date.now() % (isMobile ? 8 : 5) === 0)) {
                try {
                    hands.send({ image: videoElement });
                } catch (e) {}
            }
        }
        animate();

        // ========== 9. 手机横竖屏适配 ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

